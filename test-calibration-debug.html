<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ ‡å°ºè®¡ç®—è°ƒè¯•æµ‹è¯•</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
    }
    .section {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    textarea {
      width: 100%;
      height: 100px;
      font-family: monospace;
      padding: 10px;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
    #preview {
      border: 1px solid #ccc;
      padding: 20px;
      min-height: 100px;
      background: #f9f9f9;
    }
    #console-output {
      background: #000;
      color: #0f0;
      padding: 15px;
      font-family: monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .log-info { color: #0ff; }
    .log-success { color: #0f0; }
    .log-warning { color: #ff0; }
    .log-error { color: #f00; }
  </style>
</head>
<body>
  <h1>ğŸ” æ ‡å°ºè®¡ç®—è°ƒè¯•æµ‹è¯•</h1>
  
  <div class="section">
    <h2>è¾“å…¥ LaTeX å…¬å¼</h2>
    <textarea id="latex-input" placeholder="è¾“å…¥ LaTeX å…¬å¼ï¼Œä¾‹å¦‚ï¼š\frac{a}{b} æˆ– x^2+y^2=z^2">\frac{a}{b}</textarea>
    <button onclick="renderFormula()">æ¸²æŸ“å…¬å¼</button>
    <button onclick="clearConsole()">æ¸…ç©ºæ—¥å¿—</button>
  </div>
  
  <div class="section">
    <h2>é¢„è§ˆ</h2>
    <div id="preview"></div>
  </div>
  
  <div class="section">
    <h2>æ§åˆ¶å°è¾“å‡ºï¼ˆè¯Šæ–­æ—¥å¿—ï¼‰</h2>
    <div id="console-output"></div>
  </div>

  <script type="module">
    // æ‹¦æˆª console.log å¹¶æ˜¾ç¤ºåœ¨é¡µé¢ä¸Š
    const consoleOutput = document.getElementById('console-output');
    const originalLog = console.log;
    const originalWarn = console.warn;
    const originalError = console.error;
    
    function addToConsole(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const span = document.createElement('span');
      span.className = `log-${type}`;
      span.textContent = `[${timestamp}] ${message}\n`;
      consoleOutput.appendChild(span);
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }
    
    console.log = function(...args) {
      originalLog.apply(console, args);
      addToConsole(args.join(' '), 'info');
    };
    
    console.warn = function(...args) {
      originalWarn.apply(console, args);
      addToConsole(args.join(' '), 'warning');
    };
    
    console.error = function(...args) {
      originalError.apply(console, args);
      addToConsole(args.join(' '), 'error');
    };
    
    // å¯¼å…¥å¹¶åˆå§‹åŒ– MathJax
    import('https://cdn.jsdelivr.net/npm/mathjax@4/tex-svg.js').then(() => {
      console.log('âœ“ MathJax å·²åŠ è½½');
      addToConsole('âœ“ MathJax å·²åŠ è½½', 'success');
    }).catch(err => {
      console.error('âœ— MathJax åŠ è½½å¤±è´¥:', err);
    });
    
    // æ¸²æŸ“å‡½æ•°
    window.renderFormula = async function() {
      const latex = document.getElementById('latex-input').value.trim();
      if (!latex) {
        alert('è¯·è¾“å…¥ LaTeX å…¬å¼');
        return;
      }
      
      console.log('=== å¼€å§‹æ¸²æŸ“ ===');
      console.log('è¾“å…¥:', latex);
      
      try {
        // ç­‰å¾… MathJax åŠ è½½
        while (!window.MathJax || !window.MathJax.tex2svg) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // æ¸²æŸ“ LaTeX
        const svgElement = window.MathJax.tex2svg(latex, { display: true });
        const svg = svgElement.querySelector('svg');
        
        if (!svg) {
          throw new Error('æœªç”Ÿæˆ SVG å…ƒç´ ');
        }
        
        console.log('âœ“ SVG æ¸²æŸ“æˆåŠŸ');
        
        // æ˜¾ç¤ºé¢„è§ˆ
        const preview = document.getElementById('preview');
        preview.innerHTML = '';
        preview.appendChild(svg.cloneNode(true));
        
        // è®¡ç®—åŸºç¡€å­—ç¬¦é«˜åº¦
        console.log('=== å¼€å§‹è®¡ç®—åŸºç¡€å­—ç¬¦é«˜åº¦ ===');
        const baseGlyphHeight = calculateBaseGlyphHeight(svg);
        
        if (baseGlyphHeight > 0) {
          console.log(`âœ“ æ ‡å°ºè®¡ç®—æˆåŠŸ: ${baseGlyphHeight.toFixed(3)} (SVG å•ä½)`);
          addToConsole(`âœ“ æ ‡å°ºè®¡ç®—æˆåŠŸ: ${baseGlyphHeight.toFixed(3)} (SVG å•ä½)`, 'success');
          
          // æ·»åŠ æ ‡å°º
          addCalibrationMarker(svg, baseGlyphHeight);
          console.log('âœ“ æ ‡å°ºå·²æ·»åŠ åˆ° SVG');
          
          // æ›´æ–°é¢„è§ˆ
          preview.innerHTML = '';
          preview.appendChild(svg.cloneNode(true));
        } else {
          console.warn('âš ï¸ æ ‡å°ºè®¡ç®—å¤±è´¥: æœªæ‰¾åˆ°æœ‰æ•ˆå­—ç¬¦é«˜åº¦');
          addToConsole('âš ï¸ æ ‡å°ºè®¡ç®—å¤±è´¥: æœªæ‰¾åˆ°æœ‰æ•ˆå­—ç¬¦é«˜åº¦', 'warning');
        }
        
      } catch (error) {
        console.error('æ¸²æŸ“å¤±è´¥:', error);
      }
    };
    
    // è®¡ç®—åŸºç¡€å­—ç¬¦é«˜åº¦
    function calculateBaseGlyphHeight(svg) {
      try {
        // ä¸´æ—¶å°† SVG æ·»åŠ åˆ° DOM ä»¥ä¾¿è®¡ç®— bbox
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.left = '-9999px';
        tempContainer.style.top = '-9999px';
        tempContainer.style.visibility = 'hidden';
        document.body.appendChild(tempContainer);
        
        const svgClone = svg.cloneNode(true);
        tempContainer.appendChild(svgClone);

        // æŸ¥æ‰¾æ‰€æœ‰ <use> å…ƒç´ 
        const useElements = svgClone.querySelectorAll('use');
        console.log(`[CalibrationDebug] æ‰¾åˆ° ${useElements.length} ä¸ª <use> å…ƒç´ `);
        
        if (useElements.length === 0) {
          document.body.removeChild(tempContainer);
          console.log('[CalibrationDebug] æ²¡æœ‰ <use> å…ƒç´ ï¼Œè¿”å› 0');
          return 0;
        }

        const heights = [];
        let processedCount = 0;
        let skippedNoHref = 0;
        let skippedNoPath = 0;
        let skippedBBoxFail = 0;
        let skippedOutOfRange = 0;

        // éå†æ‰€æœ‰ <use> å…ƒç´ 
        useElements.forEach((use, index) => {
          const href = use.getAttribute('href') || use.getAttribute('xlink:href');
          if (!href) {
            skippedNoHref++;
            return;
          }

          const pathId = href.replace('#', '');
          const path = svgClone.querySelector(`#${CSS.escape(pathId)}`);
          if (!path) {
            skippedNoPath++;
            if (index < 3) {
              console.log(`[CalibrationDebug] <use> #${index}: href=${href}, æœªæ‰¾åˆ°å¯¹åº”çš„ path`);
            }
            return;
          }

          try {
            const bbox = path.getBBox();
            if (bbox && bbox.height > 0) {
              if (bbox.height >= 0.3 && bbox.height <= 3.0) {
                heights.push(bbox.height);
                processedCount++;
                if (index < 3) {
                  console.log(`[CalibrationDebug] <use> #${index}: href=${href}, height=${bbox.height.toFixed(3)}`);
                }
              } else {
                skippedOutOfRange++;
                if (index < 3) {
                  console.log(`[CalibrationDebug] <use> #${index}: href=${href}, height=${bbox.height.toFixed(3)} (è¶…å‡ºèŒƒå›´)`);
                }
              }
            } else {
              skippedBBoxFail++;
            }
          } catch (e) {
            skippedBBoxFail++;
            if (index < 3) {
              console.log(`[CalibrationDebug] <use> #${index}: getBBox() å¤±è´¥:`, e);
            }
          }
        });

        document.body.removeChild(tempContainer);

        console.log(`[CalibrationDebug] ç»Ÿè®¡: å¤„ç†=${processedCount}, æ— href=${skippedNoHref}, æ— path=${skippedNoPath}, bboxå¤±è´¥=${skippedBBoxFail}, è¶…å‡ºèŒƒå›´=${skippedOutOfRange}`);

        if (heights.length === 0) {
          console.log('[CalibrationDebug] æ²¡æœ‰æœ‰æ•ˆé«˜åº¦ï¼Œè¿”å› 0');
          return 0;
        }

        heights.sort((a, b) => a - b);
        const mid = Math.floor(heights.length / 2);
        const median = heights.length % 2 === 0
          ? (heights[mid - 1] + heights[mid]) / 2
          : heights[mid];

        console.log(`[CalibrationDebug] è®¡ç®—ä¸­ä½æ•°: ${median.toFixed(3)} (æ¥è‡ª ${heights.length} ä¸ªæœ‰æ•ˆé«˜åº¦)`);
        return median;
      } catch (error) {
        console.error('[CalibrationDebug] å¼‚å¸¸:', error);
        return 0;
      }
    }
    
    // æ·»åŠ æ ‡å°º
    function addCalibrationMarker(svg, baseGlyphHeight) {
      try {
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('id', 'mf_calib_xheight');
        rect.setAttribute('width', '1');
        rect.setAttribute('height', baseGlyphHeight.toString());
        rect.setAttribute('x', '-1000');
        rect.setAttribute('y', '0');
        rect.setAttribute('opacity', '0.01');
        rect.setAttribute('fill', 'none');
        rect.setAttribute('stroke', 'none');
        svg.appendChild(rect);
      } catch (error) {
        console.error('æ·»åŠ æ ‡å°ºå¤±è´¥:', error);
      }
    }
    
    window.clearConsole = function() {
      consoleOutput.innerHTML = '';
    };
  </script>
</body>
</html>
